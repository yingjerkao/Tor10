

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tor10.linalg &mdash; Tor10 0.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Tor10
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Symmetry.html">tor10.Symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Bond.html">tor10.Bond</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../UniTensor.html">tor10.UniTensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Network.html">tor10.Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../linalg.html">tor10.linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nn.html">tor10.nn</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Tor10</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tor10.linalg</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tor10.linalg</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.UniTensor</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="Hosvd"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Hosvd">[docs]</a><span class="k">def</span> <span class="nf">Hosvd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">bonds_group</span><span class="p">,</span><span class="n">by_label</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">core</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the higher-order SVD on a UniTensor</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            UniTensor</span>

<span class="sd">        order:</span>
<span class="sd">            a python list or 1d numpy array, indicating how the bonds should be permute before hosvd</span>

<span class="sd">        bonds_group:</span>
<span class="sd">            a python list or 1d numpy array. This indicate how the bonds of the input UniTensor should be group to perform hosvd.</span>

<span class="sd">        by_label:</span>
<span class="sd">            bool, the element in argument &quot;order&quot; represents the index of bond or label of bond. If True, all the elements in &quot;order&quot; represent the labels.</span>

<span class="sd">        core:</span>
<span class="sd">            bool, if True, the coreTensor will be compute and returned.</span>

<span class="sd">    Return:</span>
<span class="sd">        if core is true, return 2d tuple, with structure (list of unitary tensors, coreTensor)</span>

<span class="sd">        if core is False, return a list of unitary tensors.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; x = tor10.From_torch(torch.arange(0.1,2.5,0.1).reshape(2,3,4).to(torch.float64),labels=[6,7,8],rowrank=1)</span>
<span class="sd">        &gt;&gt;&gt; x.Print_diagram()</span>

<span class="sd">        &gt;&gt;&gt; print(x)</span>

<span class="sd">        &gt;&gt;&gt; factors, core = tor10.Hosvd(x,order=[7,6,8],bonds_group=[2,1],by_label=True)</span>
<span class="sd">        &gt;&gt;&gt; core.Print_diagram()</span>

<span class="sd">        &gt;&gt;&gt; print(len(factors))</span>

<span class="sd">        &gt;&gt;&gt; factor[0].Print_diagram()</span>


<span class="sd">        &gt;&gt;&gt; factor[1].Print_diagram()</span>

<span class="sd">        * Checking:</span>

<span class="sd">        &gt;&gt;&gt; rep_x = core</span>
<span class="sd">        &gt;&gt;&gt; for f in factors:</span>
<span class="sd">        &gt;&gt;&gt;     rep_x = tor10.Contract(rep_x,f)</span>
<span class="sd">        &gt;&gt;&gt; rep_x.Permute([6,7,8],rowrank=1,by_label=True)</span>
<span class="sd">        &gt;&gt;&gt; print(rep_x - x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Hosvd(UniTensor,*args)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the input should be a UniTensor&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bonds_group</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bonds_group</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Hosvd(UniTensor,order,bonds_group,*args)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the bonds_group should be a python list or 1d numpy array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Hosvd(UniTensor,order,bonds_group,*args)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the order should be a python list or 1d numpy array&quot;</span><span class="p">)</span>

    <span class="c1">## checking:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hosvd&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the size of order should be equal to the rank of input UniTensor. size of order:</span><span class="si">%d</span><span class="s2">; rank of UniTensor:</span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)))</span>

    <span class="c1">## checking:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Hosvd&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR], Hosvd can only perform on a UniTensor with rank &gt; 2. For a rank-2 tensor, using Svd() instead.&quot;</span><span class="p">)</span>

    <span class="c1">## checking:</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span> <span class="n">x</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bonds_group</span><span class="p">):</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hosvd&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] bonds_group cannot have elements &lt;=0&quot;</span><span class="p">)</span>



    <span class="c1">## master switch</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Hosvd can only operate on non-symmetry tensor&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
    
        <span class="n">old_labels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">old_bonds</span>  <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">by_label</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">id</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">order</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hosvd&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] by_label=False but the input &#39;order&#39; exceed the rank of UniTensor&quot;</span><span class="p">)</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

        <span class="n">iod</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="o">==</span><span class="n">mapper</span><span class="p">[</span><span class="n">x</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapper</span><span class="p">))]</span>
        <span class="n">old_Nin</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">start_label</span> <span class="o">=</span> <span class="n">start_label</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">start_label</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">bg</span> <span class="ow">in</span> <span class="n">bonds_group</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">_Permute</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span><span class="n">rowrank</span><span class="o">=</span><span class="n">bg</span><span class="p">,</span><span class="n">by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">## manipulate only the Storage, keep the shell of UniTensor unchange.</span>
            <span class="n">old_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">a</span><span class="o">.</span><span class="n">Contiguous</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="n">Storage</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">bg</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">u</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>

            <span class="n">new_bonds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">[:</span><span class="n">bg</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">new_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[:</span><span class="n">bg</span><span class="p">]),</span><span class="n">start_label</span><span class="p">)</span>
            <span class="n">iiod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iod</span><span class="p">[:</span><span class="n">bg</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmpt</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="n">new_bonds</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="n">new_labels</span><span class="p">,</span><span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tmpt</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">old_shape</span><span class="p">[:</span><span class="n">bg</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">tmpt</span> <span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">iiod</span><span class="p">)</span>       
            <span class="n">factors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_Permute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">rowrank</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">iiod</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">a</span><span class="o">.</span><span class="n">Storage</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)</span>
            <span class="n">start_label</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span><span class="o">-</span><span class="n">bg</span><span class="p">)</span>
            <span class="n">iod</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">iod</span><span class="p">,</span><span class="o">-</span><span class="n">bg</span><span class="p">)</span>

        <span class="n">a</span><span class="o">.</span><span class="n">_Permute</span><span class="p">(</span><span class="n">old_labels</span><span class="p">,</span><span class="n">rowrank</span><span class="o">=</span><span class="n">old_Nin</span><span class="p">,</span><span class="n">by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">old_bonds</span>

        <span class="c1">## if compute core?</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">factors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">Whole_transpose</span><span class="p">()</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">Contract</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                <span class="n">n</span><span class="o">.</span><span class="n">Whole_transpose</span><span class="p">()</span>
            
            <span class="k">return</span> <span class="n">factors</span><span class="p">,</span><span class="n">out</span></div>



<div class="viewcode-block" id="Abs"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Abs">[docs]</a><span class="k">def</span> <span class="nf">Abs</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1">## v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take the absolute value for all the elements in the UniTensor</span>
<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            UniTensor, can be [untagged][tagged][symm]</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor, same shape and type as the input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Abs(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the input should be a UniTensor&quot;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>\
                         <span class="n">rowrank</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">rowrank</span><span class="p">,</span>\
                         <span class="n">labels</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>\
                         <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Storage</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Storage</span><span class="p">))],</span>\
                           <span class="n">braket</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span><span class="p">,</span>\
                           <span class="n">sym_mappers</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_inv_mapper</span><span class="p">,</span>\
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_bra_mapper_blks</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_bra_invmapper_blks</span><span class="p">,</span>\
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_ket_mapper_blks</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ket_invmapper_blks</span><span class="p">,</span>\
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_contiguous</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_accu_off_in</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_accu_off_out</span><span class="p">))</span>
                         
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>\
                         <span class="n">rowrank</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">rowrank</span><span class="p">,</span>\
                         <span class="n">labels</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>\
                         <span class="n">is_diag</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">,</span>\
                         <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">braket</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span><span class="p">,</span>\
                            <span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tmp</span></div>
<div class="viewcode-block" id="Mean"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Mean">[docs]</a><span class="k">def</span> <span class="nf">Mean</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1">## v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the mean of all elements in the input non-symmetry UniTensor</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            UniTensor, can be [untagged][tagged]</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor, 0-rank (constant)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mean(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the input should be a UniTensor&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mean(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] cannot get mean for a symmetry tensor. GetBlock first&quot;</span><span class="p">)</span>
    
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="p">[],</span><span class="n">labels</span><span class="o">=</span><span class="p">[],</span><span class="n">rowrank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tmp</span></div>
<div class="viewcode-block" id="Otimes"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Otimes">[docs]</a><span class="k">def</span> <span class="nf">Otimes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform matrix product for two rank-2 tensors.</span>

<span class="sd">        :math:`a \otimes b`</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            UniTensor, must be rank-2, [untagged], with 1-inbond and 1-outbond</span>

<span class="sd">        b:</span>
<span class="sd">            UniTensor, must be rank-2, [untagged], with 1-inbond and 1-outbond</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor, rank-2, one in-bond one out-bond. [untagged]</span>
<span class="sd">        If both a and b are diagonal matrix (is_diag=True), the return UniTensor will be a diagonal tensor.</span>

<span class="sd">        If one of the input tensor is diagonal matrix and the other is not, the return UniTensor will be densed.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;linalg.Otimes&quot;</span><span class="p">,</span><span class="s2">&quot;Otimes can only accept untagged tensor.&quot;</span><span class="p">)</span> 

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">rowrank</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>

                <span class="n">tmp</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>\
                                 <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                                 <span class="n">is_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ger</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">tmp</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
                <span class="n">tmpa</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmpa</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Storage</span>

            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
                <span class="n">tmpb</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmpb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">Storage</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                             <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                             <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tmp</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Otimes&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR], Otimes only accept rank-2 UniTensors as arguments.&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Otimes&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR], Otimes only accept UniTensor as arguments.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="ExpH"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.ExpH">[docs]</a><span class="k">def</span> <span class="nf">ExpH</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1"># v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs</span>

<span class="sd">            :math:`e^{H}`</span>

<span class="sd">    where H is the hermitian matrix.</span>
<span class="sd">    The Intricate computation follows procedure: symeig() -&gt; exp() the singular matrix.</span>

<span class="sd">    Args:</span>

<span class="sd">        a :</span>
<span class="sd">            UniTensor, Must be a rank-2 [untagged], with one inbond, one outbond. If pass a non-rank2 tensor, tagged tensor, or pass a non-hermitian rank2 tensor; it will raise Error.</span>

<span class="sd">    Return:</span>

<span class="sd">        UniTensor, rank-2 [unregular], same bonds and labels and braket form as the original H</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
           <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ExpH(a)&quot;</span><span class="p">,</span><span class="s2">&quot;don&#39;t support symm tensor. GetBlock first.&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ExpH(a)&quot;</span><span class="p">,</span><span class="s2">&quot;can only accept [untagged] type UniTensor&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>   
                <span class="n">u</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>
                
                <span class="n">tmp</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>\
                                 <span class="n">labels</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>\
                                 <span class="n">rowrank</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">rowrank</span><span class="p">,</span>\
                                 <span class="n">is_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>\
                                 <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tmp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ExpH(a)&quot;</span><span class="p">,</span><span class="s2">&quot;a should be rank-2 tensor with 1 inbond 1 outbond&quot;</span><span class="p">)</span>

                <span class="c1">## version-1, only real, not sure if it can extend to complex</span>
                <span class="n">s</span> <span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">symeig</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">eigenvectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">s</span>     <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                <span class="c1"># torch.matmul(u*s,u.transpose(0,1),out=u)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">del</span> <span class="n">s</span>

                <span class="n">tmp</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>\
                                <span class="n">labels</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>\
                                <span class="n">rowrank</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">rowrank</span><span class="p">,</span>\
                                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ExpH(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] ExpH can only accept UniTensor&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="Qr"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Qr">[docs]</a><span class="k">def</span> <span class="nf">Qr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1"># v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The function performs the qr decomposition</span>

<span class="sd">        :math:`a = q \cdot r`</span>

<span class="sd">    to the input UniTensor. The UniTensor should be rank-2, untagged. each bond&#39;s dim should be &gt;=2.</span>


<span class="sd">    Args:</span>

<span class="sd">        a : UniTensor[untagged], it is required to be a non-diagonal rank-2 tensor. If pass a non rank-2 tensor or diagonal matrix, it will throw Exception.</span>

<span class="sd">    Return:</span>

<span class="sd">        q , r</span>

<span class="sd">        q : UniTensor[regular], rank-2, 1 inbond 1 outbond, the unitary matrix</span>

<span class="sd">        r : UniTensor[regular], rank-2, 1 inbond 1 outbond, the upper triangular matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>

        <span class="c1">## Qnum_ipoint</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(a)&quot;</span><span class="p">,</span><span class="s2">&quot;don&#39;t support symm tensor. GetBlock() first&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[Aboart] Currently not support diagonal tensors.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;Can only accept [untagged] tensor&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;Should have 1 in-bond, 1 out-bond&quot;</span><span class="p">)</span>

        <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="n">tq</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tq</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>

        <span class="n">tr</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">tq</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">r</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tq</span><span class="p">,</span><span class="n">tr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Qr can only accept UniTensor&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Qdr"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Qdr">[docs]</a><span class="k">def</span> <span class="nf">Qdr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1"># v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The function performs the qdr decomposition</span>

<span class="sd">        :math:`a = q \cdot d \cdot r`</span>

<span class="sd">    to input UniTensor. The UniTensor should be rank-2, untagged. with eachbond&#39;s dim should be &gt;=2.</span>

<span class="sd">    Args:</span>
<span class="sd">        a :</span>
<span class="sd">            UniTensor [untagged], rank-2, 1 inbond 1 outbond.</span>

<span class="sd">    Return: q , r</span>
<span class="sd">        q :</span>
<span class="sd">            UniTensor [untagged], rank-2, 1 inbond 1 outbond, the unitary matrix</span>

<span class="sd">        d :</span>
<span class="sd">            The diagonal matrix [untagged]. It is a diagonal rank-2 UniTensor with 1 inbond 1 outbond and is_diag=True.</span>
<span class="sd">        r :</span>
<span class="sd">            UniTensor [untagged], rank-2, 1 inbond 1 outbond, the upper triangular matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>

        <span class="c1">## Qnum_ipoint</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qdr(a)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] curretly don&#39;t support symm tensor.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[Aboart] Currently not support diagonal tensors.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;can only operate on [regular](untagged) tensor&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qdr(a)&quot;</span><span class="p">,</span><span class="s2">&quot;Should have 1 inbond 1 outbond&quot;</span><span class="p">)</span>

        
        <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">diag</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">/</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">()</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="n">tq</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tq</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">q</span><span class="p">)</span>

        <span class="n">td</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">tmp</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>\
                      <span class="n">is_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">td</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">tr</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">td</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">r</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tq</span><span class="p">,</span><span class="n">td</span><span class="p">,</span><span class="n">tr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qdr(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Qdr can only accept UniTensor&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Svd"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Svd">[docs]</a><span class="k">def</span> <span class="nf">Svd</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The function performs the svd</span>

<span class="sd">        :math:`a = u \cdot s \cdot vt`</span>

<span class="sd">    to input UniTensor. The UniTensor should be rank-2,untagged. each bond&#39;s dim should be &gt;=2.</span>

<span class="sd">    Args:</span>
<span class="sd">        a :</span>
<span class="sd">            UniTensor[untagged], rank-2.</span>

<span class="sd">    Return: u , s , vt</span>
<span class="sd">        u :</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond, the unitary matrix</span>

<span class="sd">        s :</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond, the diagonal, singular matrix, with is_diag=True</span>

<span class="sd">        vt:</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond, the transposed right unitary matrix</span>


<span class="sd">    Example:</span>
<span class="sd">    ::</span>
<span class="sd">        y = tor10.UniTensor(bonds=[tor10.Bond(3),tor10.Bond(4)],rowrank=1)</span>
<span class="sd">        y.SetElem([1,1,0,1,</span>
<span class="sd">                   0,0,0,1,</span>
<span class="sd">                   1,1,0,0]</span>


<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[1., 1., 0., 1.],</span>
<span class="sd">            [0., 0., 0., 1.],</span>
<span class="sd">            [1., 1., 0., 0.]], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; u,s,vt = tor10.linalg.Svd(y)</span>
<span class="sd">    &gt;&gt;&gt; print(u)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[-0.7887, -0.2113, -0.5774],</span>
<span class="sd">            [-0.2113, -0.7887,  0.5774],</span>
<span class="sd">            [-0.5774,  0.5774,  0.5774]], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; print(s)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : True</span>
<span class="sd">    tensor([2.1753e+00, 1.1260e+00, 1.0164e-16], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; print(vt)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[-6.2796e-01, -6.2796e-01,  0.0000e+00, -4.5970e-01],</span>
<span class="sd">            [ 3.2506e-01,  3.2506e-01,  0.0000e+00, -8.8807e-01],</span>
<span class="sd">            [-7.0711e-01,  7.0711e-01,  0.0000e+00,  1.1309e-16]],</span>
<span class="sd">            dtype=torch.float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>

        <span class="c1">## Qnum_ipoint</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] svd curretly don&#39;t support symm tensor.&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] svd currently don&#39;t support diagonal tensor.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;can only accept UniTensor[regular] (untagged)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;should be a UniTensor with 1 in-bond, 1 out-bond&quot;</span><span class="p">)</span>

        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">some</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

       

        <span class="n">tu</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

        <span class="n">tv</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">tmp</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tv</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span>  <span class="o">=</span><span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tv</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>\
                      <span class="n">labels</span> <span class="o">=</span><span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tv</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>\
                      <span class="n">is_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tu</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">tv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Svd(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Svd can only accept UniTensor&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="Svd_truncate"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Svd_truncate">[docs]</a><span class="k">def</span> <span class="nf">Svd_truncate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1">#v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The function performs the svd to input UniTensor, and truncate [truncate] dim from the smallest singular value to the tensor. The UniTensor should be rank-2. each bond&#39;s dim should be &gt;=2.</span>


<span class="sd">    Args:</span>
<span class="sd">        a :</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond.</span>

<span class="sd">        keepdim:</span>
<span class="sd">            integer, the keeping dimension. When set, it will keep only the largest &quot;keepdim&quot; singular values and their corresponding eigenvectors.</span>


<span class="sd">    Return: u , s , vt</span>
<span class="sd">        u :</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond, the truncated unitary matrix with shape (a.shape()[0], truncate)</span>

<span class="sd">        s :</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond, the diagonal, truncated singular matrix with shape (truncate,truncate)</span>

<span class="sd">        vt:</span>
<span class="sd">            UniTensor[untagged], rank-2, 1 inbond 1 outbond, the transposed right unitary matrix with shape (truncate,a.shape()[1])</span>


<span class="sd">    Example:</span>
<span class="sd">    ::</span>
<span class="sd">        y = tor10.UniTensor(bonds=[tor10.Bond(3),tor10.Bond(4)],rowrank=1)</span>
<span class="sd">        y.SetElem([1,1,0,1,</span>
<span class="sd">                   0,0,0,1,</span>
<span class="sd">                   1,1,0,0])</span>

<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[1., 1., 0., 1.],</span>
<span class="sd">            [0., 0., 0., 1.],</span>
<span class="sd">            [1., 1., 0., 0.]], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; u,s,vt = tor10.linalg.Svd_truncate(y,keepdim=2)</span>
<span class="sd">    &gt;&gt;&gt; print(u)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[-0.7887, -0.2113],</span>
<span class="sd">            [-0.2113, -0.7887],</span>
<span class="sd">            [-0.5774,  0.5774]], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; print(s)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : True</span>
<span class="sd">    tensor([2.1753, 1.1260], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; print(vt)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[-0.6280, -0.6280,  0.0000, -0.4597],</span>
<span class="sd">            [ 0.3251,  0.3251,  0.0000, -0.8881]], dtype=torch.float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>

        <span class="c1">## Qnum_ipoint</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Qdr(a)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] curretly don&#39;t support symm tensor.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] svd currently don&#39;t support diagonal tensor.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;svd can only accept untagged UniTensor[regular]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;svd(a)&quot;</span><span class="p">,</span><span class="s2">&quot;should be a UniTensor with 1 in-bond, 1 out-bond&quot;</span><span class="p">)</span>

        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">some</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keepdim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keepdim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">keepdim</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Svd_truncate&quot;</span><span class="p">,</span> <span class="s2">&quot;[ERROR] the keepdim=</span><span class="si">%d</span><span class="s2"> is invalid, must larger than 0 and smaller than the total number of eigenvalues.&quot;</span> <span class="o">%</span> <span class="n">keepdim</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="n">keepdim</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">keepdim</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="p">:</span><span class="n">keepdim</span><span class="p">]</span>

        <span class="n">tu</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

        <span class="n">tv</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">Bond</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Bond</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">tmp</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tv</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span>  <span class="o">=</span><span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tv</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>\
                      <span class="n">labels</span> <span class="o">=</span><span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tv</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>\
                      <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                      <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>\
                      <span class="n">is_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tu</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">tv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Svd_truncate(UniTensor,int)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Svd_truncate can only accept UniTensor&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Matmul"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Matmul">[docs]</a><span class="k">def</span> <span class="nf">Matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs matrix multiplication on the rank-2 UniTensors.</span>

<span class="sd">        :math:`A \cdot B`</span>

<span class="sd">    Note that both the UniTensors should be rank-2,untagged, and dimension should be matched.</span>

<span class="sd">    If a and b are both diagonal matrix, the return will be a diagonal matrix. If one (or both) of them are non-diagonal matrix and the other is diagonal matrix, the return will be a dense matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            The UniTensors that will be matrix-multiply, UniTensor should be [untagged]</span>

<span class="sd">        b:</span>
<span class="sd">            The UniTensors that will be matrix-multiply, UniTensor should be [untagged]</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor,rank-2 tensor with 1 inbond 1 outbond.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>

        <span class="c1">## [Note] no need to check if a,b are both rank 2. Rely on torch to do error handling!</span>
       

        <span class="c1">## Qnum_ipoint</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_symm</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Matmul(a,b)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] Matmul cannot operate on sym TN.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Matmul(a,b)&quot;</span><span class="p">,</span><span class="s2">&quot;Matmul can only accept two regular Tensors&quot;</span><span class="p">)</span>

        
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Matmul(a,b)&quot;</span><span class="p">,</span><span class="s2">&quot;Matmul can only accept two UniTensor with each has 1 inbond and 1 outbond&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">b</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                            <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>\
                            <span class="n">is_diag</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">b</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                                <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">),</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">b</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                                <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">Storage</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;_Matmul(a,b)&quot;</span><span class="p">,</span> <span class="s2">&quot;[ERROR] _Matmul can only accept UniTensors for both a &amp; b&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Chain_matmul"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Chain_matmul">[docs]</a><span class="k">def</span> <span class="nf">Chain_matmul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs matrix multiplication on all the UniTensors.</span>

<span class="sd">        :math:`A \cdot B \cdot C \cdot D \cdots`</span>

<span class="sd">    Note that</span>

<span class="sd">    1. all the UniTensors should be rank-2,untagged, and dimension should be matched.</span>

<span class="sd">    2. The input UniTensors can have some of them are diagonal matrix (is_diag=True). The return will always be a rank-2 UniTensor with is_diag=False</span>

<span class="sd">    Args:</span>
<span class="sd">        *args:</span>
<span class="sd">            The UniTensors that will be matrix-multiply. Each UniTensor should be [untagged] and with 1 inbond and 1 outbond</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor,rank-2 tensor with 1 inbond, 1 outbond, and default labels.</span>

<span class="sd">    Example:</span>
<span class="sd">    ::</span>
<span class="sd">        a = tor10.UniTensor(bonds=[tor10.Bond(3),tor10.Bond(4)],rowrank=1)</span>
<span class="sd">        b = tor10.UniTensor(bonds=[tor10.Bond(4),tor10.Bond(5)],rowrank=1)</span>
<span class="sd">        c = tor10.UniTensor(bonds=[tor10.Bond(5),tor10.Bond(6)],rowrank=1)</span>
<span class="sd">        d = tor10.UniTensor(bonds=[tor10.Bond(6),tor10.Bond(2)],rowrank=1)</span>

<span class="sd">    &gt;&gt;&gt; f = tor10.Chain_matmul(a,b,c,d)</span>
<span class="sd">    &gt;&gt;&gt; f.Print_diagram()</span>
<span class="sd">    -----------------------</span>
<span class="sd">    tensor Name : </span>
<span class="sd">    tensor Rank : 2</span>
<span class="sd">    has_symmetry: False</span>
<span class="sd">    on device     : cpu</span>
<span class="sd">    is_diag       : False</span>
<span class="sd">                -------------      </span>
<span class="sd">               /             \     </span>
<span class="sd">         0 ____| 3         2 |____ 1  </span>
<span class="sd">               \             /     </span>
<span class="sd">                -------------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">idiag</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">idiag</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">isUT</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">UT</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">)</span> <span class="k">for</span> <span class="n">UT</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>


    <span class="c1">## Checking performance:</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#for i in range(len(tmp_args)):</span>
    <span class="c1">#    if not tmp_args[i] is args[i].Storage:</span>
    <span class="c1">#       print(&quot;Fatal performance&quot;)</span>
    <span class="c1">#       exit(1)</span>
    <span class="c1">#&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">isUT</span><span class="p">:</span>
        <span class="c1">## Qnum_ipoint</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span> <span class="n">UT</span><span class="o">.</span><span class="n">is_symm</span><span class="o">==</span><span class="kc">False</span> <span class="k">for</span> <span class="n">UT</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Chain_matmul(*args)&quot;</span><span class="p">,</span><span class="s2">&quot;[Abort] Chain multiplication for symm tensor(s) are under developing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span> <span class="n">UT</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">UT</span><span class="o">.</span><span class="n">rowrank</span><span class="o">==</span><span class="mi">1</span> <span class="k">for</span> <span class="n">UT</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Chain_matmul(*args)&quot;</span><span class="p">,</span><span class="s2">&quot;Chain mult should have all UniTensor have 1 inbond 1 outbond&quot;</span><span class="p">)</span>

        <span class="n">tmp_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Storage</span><span class="p">,</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_diag</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))]</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>\
                         <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                         <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">chain_matmul</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_args</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;_Chain_matmul(*args)&quot;</span><span class="p">,</span> <span class="s2">&quot;[ERROR] _Chain_matmul can only accept UniTensors for all elements in args&quot;</span><span class="p">)</span></div>






<div class="viewcode-block" id="Inverse"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Inverse">[docs]</a><span class="k">def</span> <span class="nf">Inverse</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1">#v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the inverse of a rank-2 tensor (matrix).</span>

<span class="sd">        :math:`a^{-1}`</span>

<span class="sd">    If the input UniTensor is diagonal, the return will also be a diagonal matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        a :</span>
<span class="sd">            A rank-2 UniTensor[untagged] (matrix), with 1-inbond. 1-outbond. Note that if the matrix is not inversable, error will be issued. passing a non-rank2 UniTensor, error will be issued.</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inverse&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] cannot inverse a symmetry tensor&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inverse&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] inverse can only accept untagged UniTensor[regular]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inverse&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] inverse should have UniTensor with rowrank=1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="n">a_inv</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>\
                          <span class="n">labels</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>\
                          <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                          <span class="n">is_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>\
                          <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">a_inv</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">a_inv</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>\
                              <span class="n">labels</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>\
                              <span class="n">rowrank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>\
                              <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">a_inv</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">a_inv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inverse(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Inverse can only accept UniTensor&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Det"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Det">[docs]</a><span class="k">def</span> <span class="nf">Det</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> 
    <span class="c1">#v0.3 OK</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the determinant a rank-2 tensor.</span>

<span class="sd">    :math:`\det(a)`</span>

<span class="sd">    Args:</span>
<span class="sd">        a :</span>
<span class="sd">            a rank-2 UniTensor [untagged] (matrix) with 1 inbond 1 outbond.</span>
<span class="sd">    Return:</span>
<span class="sd">        UniTensor, 0-rank (constant)</span>

<span class="sd">    Example:</span>
<span class="sd">    ::</span>
<span class="sd">        a = tor10.UniTensor(bonds=[tor10.Bond(3),tor10.Bond(3)])</span>
<span class="sd">        a.SetElem([4,-3,0,</span>
<span class="sd">                   2,-1,2,</span>
<span class="sd">                   1, 5,7])</span>
<span class="sd">        b = tor10.UniTensor(bonds=[tor10.Bond(3),tor10.Bond(3)],is_diag=True)</span>
<span class="sd">        b.SetElem([1,2,3])</span>

<span class="sd">    &gt;&gt;&gt; print(a)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor([[ 4., -3.,  0.],</span>
<span class="sd">            [ 2., -1.,  2.],</span>
<span class="sd">            [ 1.,  5.,  7.]], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; out = tor10.Det(a)</span>
<span class="sd">    &gt;&gt;&gt; print(out)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor(-32., dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : True</span>
<span class="sd">    tensor([1., 2., 3.], dtype=torch.float64)</span>

<span class="sd">    &gt;&gt;&gt; out = tor10.Det(b)</span>
<span class="sd">    &gt;&gt;&gt; print(out)</span>
<span class="sd">    Tensor name:</span>
<span class="sd">    is_diag    : False</span>
<span class="sd">    tensor(6., dtype=torch.float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Det&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] cannot operate deteminant on a symmetry tensor&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Det&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] det can only operate on untagged UniTensor[regular]&quot;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Det&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] det should have a rank-2 UniTensor with rowrank=1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_diag</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span>  <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="p">[],</span><span class="n">labels</span><span class="o">=</span><span class="p">[],</span><span class="n">rowrank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Det(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Det can only accept UniTensor&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Norm"><a class="viewcode-back" href="../../linalg.html#tor10.linalg.Norm">[docs]</a><span class="k">def</span> <span class="nf">Norm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the matrix norm of the UniTensor. The input tensor should be untagged. </span>

<span class="sd">    If the given UniTensor is a matrix (rank-2), matrix norm will be calculated. If the given UniTensor is a vector (rank-1), vector norm will be calculated. If the given UniTensor has more than 2 ranks, the vector norm will be appllied to last dimension. </span>


<span class="sd">    Args:</span>
<span class="sd">        a :</span>
<span class="sd">            a UniTensor[untagged]</span>

<span class="sd">    Return:</span>
<span class="sd">        UniTensor, 0-rank (constant)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">UniTensor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_symm</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Norm&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] cannot operate Norm on a symmetry tensor&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">braket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Norm&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Norm can only operate on untagged UniTensor&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rowrank</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Norm&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] the input UniTensor should be rank-2, untagged with rowrank=1&quot;</span><span class="p">)</span>


        <span class="c1">#tmp = torch.norm(a.Storage)</span>
        <span class="c1">#if len(tmp.shape) != 0:</span>
        <span class="c1">#    return UniTensor(bonds=[tor10.Bond(tmp.shape[i]) for i in range(len(tmp.shape))],rowrank=1,torch_tensor=tmp,check=False)</span>
        <span class="c1">#else:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">UniTensor</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="p">[],</span><span class="n">labels</span><span class="o">=</span><span class="p">[],</span><span class="n">rowrank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">_mac</span><span class="p">(</span><span class="n">torch_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Storage</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tmp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Norm(UniTensor)&quot;</span><span class="p">,</span><span class="s2">&quot;[ERROR] Norm can only accept UniTensor&quot;</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Kai-Hsin Wu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>